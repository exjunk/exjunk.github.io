<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Getting Started with WebGPU on Android: A Complete Guide | Android Tech Blog</title>
<meta name="keywords" content="">
<meta name="description" content="
WebGPU is the next-generation graphics API that brings modern GPU capabilities to the web and native applications. While it’s primarily known for web browsers, Google has been working on bringing WebGPU to Android through the AndroidX library. In this guide, we’ll walk through setting up WebGPU in your Android app and rendering your first triangle.
What is WebGPU?
Before diving into the code, let’s understand what WebGPU actually is. Think of your phone’s GPU (Graphics Processing Unit) as a powerful calculator that specializes in graphics operations. WebGPU is a modern interface that lets developers communicate with this GPU efficiently. It’s designed to be faster and more flexible than older technologies like OpenGL ES, which has been the standard for Android graphics for years.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/getting-started-with-webgpu-on-android/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/getting-started-with-webgpu-on-android/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Android Tech Blog (Alt + H)">Android Tech Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/contact/" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/privacy/" title="Privacy">
                    <span>Privacy</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Getting Started with WebGPU on Android: A Complete Guide
    </h1>
    <div class="post-meta"><span title='2025-12-07 23:23:14 +0530 IST'>December 7, 2025</span>&nbsp;·&nbsp;<span>12 min</span>

</div>
  </header> 
  <div class="post-content"><p><img alt="image" loading="lazy" src="https://miro.medium.com/v2/resize:fit:1400/1*koS6xt8rmVND1CyT5SohwA.png"></p>
<p>WebGPU is the next-generation graphics API that brings modern GPU capabilities to the web and native applications. While it’s primarily known for web browsers, Google has been working on bringing WebGPU to Android through the AndroidX library. In this guide, we’ll walk through setting up WebGPU in your Android app and rendering your first triangle.</p>
<h2 id="what-is-webgpu">What is WebGPU?<a hidden class="anchor" aria-hidden="true" href="#what-is-webgpu">#</a></h2>
<p>Before diving into the code, let’s understand what WebGPU actually is. Think of your phone’s GPU (Graphics Processing Unit) as a powerful calculator that specializes in graphics operations. WebGPU is a modern interface that lets developers communicate with this GPU efficiently. It’s designed to be faster and more flexible than older technologies like OpenGL ES, which has been the standard for Android graphics for years.</p>
<p>The beauty of WebGPU is that it provides a unified way to work with graphics across different platforms, whether you’re building for web, Android, or desktop applications.</p>
<p><strong>WebGPU: From Web to Native Android</strong></p>
<p>WebGPU originated as a web standard for modern GPU access in browsers like Chrome and Edge, built on Google’s Dawn implementation. Dawn translates WebGPU calls into native graphics APIs: Vulkan on Android, Metal on iOS, and Direct3D on Windows. Google introduced the AndroidX WebGPU library, bringing this same powerful API to native Android development. The library packages Dawn into native ‘.so’ files and provides a Kotlin-friendly interface, meaning graphics code can now be shared between web and Android apps with minimal changes. This makes WebGPU an exciting choice for developers building cross-platform graphics applications.</p>
<p><strong>Understanding the Graphics Pipeline</strong></p>
<p>When you want to draw something on screen, like a triangle, the process happens in stages, similar to an assembly line in a factory. This is called the graphics pipeline.</p>
<p>The pipeline has several key stages, but we’ll focus on two main ones:</p>
<p><strong>Vertex Stage</strong>: This is where you define the positions of your shapes. Think of vertices as the corner points of your triangle. You tell the GPU, “I want a triangle with three points at these specific locations on the screen.”</p>
<p><strong>Fragment Stage</strong>: After the GPU knows where your triangle is, it needs to know what color to paint it. The fragment stage is where you decide the color and appearance of every pixel inside your triangle. You can think of it as the painting stage after you’ve drawn the outline.</p>
<p>These stages are controlled by small programs called shaders, which are written in a special language. Don’t worry if this sounds complex; we’ll break it down step by step.</p>
<h2 id="project-setup">Project Setup<a hidden class="anchor" aria-hidden="true" href="#project-setup">#</a></h2>
<p>Let’s start by setting up a new Android project. You can use Android Studio to create a standard Compose project. Make sure you’re targeting at least API level 24 (Android 7.0).</p>
<p><strong>Step 1: Configuring Your Build File</strong></p>
<p>Open your app-level build.gradle.kts file and add the WebGPU library. This file tells Android Studio which external libraries your app needs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>dependencies {
</span></span><span style="display:flex;"><span>    implementation(<span style="color:#e6db74">&#34;androidx.webgpu:webgpu:1.0.0-alpha01&#34;</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You’ll also need to configure native library support. WebGPU relies on native C++ code under the hood, so we need to tell Android which CPU architectures to support</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>android {
</span></span><span style="display:flex;"><span>    defaultConfig {
</span></span><span style="display:flex;"><span>        ndk {
</span></span><span style="display:flex;"><span>            abiFilters <span style="color:#f92672">+=</span> listOf(<span style="color:#e6db74">&#34;armeabi-v7a&#34;</span>, <span style="color:#e6db74">&#34;arm64-v8a&#34;</span>, <span style="color:#e6db74">&#34;x86&#34;</span>, <span style="color:#e6db74">&#34;x86_64&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    sourceSets {
</span></span><span style="display:flex;"><span>        getByName(<span style="color:#e6db74">&#34;main&#34;</span>) {
</span></span><span style="display:flex;"><span>            jniLibs.srcDirs(<span style="color:#e6db74">&#34;src/main/jniLibs&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    packaging {
</span></span><span style="display:flex;"><span>        jniLibs {
</span></span><span style="display:flex;"><span>            useLegacyPackaging = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let me explain what each architecture means:</p>
<ul>
<li>arm64-v8a: Modern 64-bit ARM processors (almost all current Android phones)</li>
<li>armeabi-v7a: Older 32-bit ARM processors (phones from before 2017)</li>
<li>x86_64: 64-bit Intel processors (mostly for emulators)</li>
<li>x86: 32-bit Intel processors (older emulators)</li>
</ul>
<h2 id="step-2-downloading-the-native-libraries">Step 2: Downloading the Native Libraries<a hidden class="anchor" aria-hidden="true" href="#step-2-downloading-the-native-libraries">#</a></h2>
<p>WebGPU needs native library files to work. These files have a .so extension and contain the compiled C++ code that actually talks to your device&rsquo;s GPU.</p>
<p>You can download from <a href="https://git.codelinaro.org/clo/la/platform/prebuilts/androidx/webgpu">https://git.codelinaro.org/clo/la/platform/prebuilts/androidx/webgpu</a> . You&rsquo;ll find a folder structure with four subdirectories, each containing a file named libwebgpu_c_bundled.so.</p>
<p>The repository structure looks like this</p>
<pre tabindex="0"><code>jni/
  ├── arm64-v8a/
  │   └── libwebgpu_c_bundled.so
  ├── armeabi-v7a/
  │   └── libwebgpu_c_bundled.so
  ├── x86/
  │   └── libwebgpu_c_bundled.so
  └── x86_64/
      └── libwebgpu_c_bundled.so
</code></pre><p><strong>Step 3: Organizing the Native Libraries</strong></p>
<p>In your Android project, create a folder structure to house these native libraries. Navigate to your project and create the following path</p>
<pre tabindex="0"><code>app/src/main/jniLibs/
</code></pre><p>Note the capital ‘L’ in jniLibs. This naming is important because Android Studio looks for native libraries specifically in a folder with this exact name.</p>
<p>Copy the entire folder structure from the downloaded files into this jniLibs folder. Your final structure should look like</p>
<pre tabindex="0"><code>app/
  └── src/
      └── main/
          ├── jniLibs/
          │   ├── arm64-v8a/
          │   │   └── libwebgpu_c_bundled.so
          │   ├── armeabi-v7a/
          │   │   └── libwebgpu_c_bundled.so
          │   ├── x86/
          │   │   └── libwebgpu_c_bundled.so
          │   └── x86_64/
          │       └── libwebgpu_c_bundled.so
          └── java/
              └── (your package)
</code></pre><p>When you build your app, Android will automatically select the correct .so file based on the device&rsquo;s processor architecture. You don&rsquo;t need to write any code to handle this selection.</p>
<h3 id="creating-the-renderer">Creating the Renderer<a hidden class="anchor" aria-hidden="true" href="#creating-the-renderer">#</a></h3>
<p>Now comes the exciting part: writing code to actually render graphics. We’ll create a class called WebGPURenderer that manages all GPU operations.</p>
<p><strong>Understanding the Renderer Structure</strong></p>
<p>The renderer needs to handle several responsibilities:</p>
<ol>
<li>Load the native library</li>
<li>Initialize the GPU connection</li>
<li>Create a surface to draw on</li>
<li>Set up the rendering pipeline</li>
<li>Execute the rendering loop</li>
</ol>
<p>Let’s build this step by step.</p>
<p><strong>Loading the Native Library</strong></p>
<p>First, we need to load the native library we placed in the jniLibs folder. This happens in a companion object, which runs when the class is first used</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WebGPURenderer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">companion</span> <span style="color:#66d9ef">object</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">init</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">System</span>.loadLibrary(<span style="color:#e6db74">&#34;webgpu_c_bundled&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Log</span>.d(<span style="color:#e6db74">&#34;WebGPU&#34;</span>, <span style="color:#e6db74">&#34;Library loaded successfully&#34;</span>)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (e: UnsatisfiedLinkError) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Log</span>.e(<span style="color:#e6db74">&#34;WebGPU&#34;</span>, <span style="color:#e6db74">&#34;Failed to load library&#34;</span>, e)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice how we use &ldquo;webgpu_c_bundled&rdquo; and not &ldquo;libwebgpu_c_bundled&rdquo;. Android automatically adds the lib prefix and .so extension, so we only need to provide the middle part of the filename.</p>
<p><strong>Initializing the GPU</strong></p>
<p>To use the GPU, we need to go through an initialization sequence. Think of this as introducing yourself to the GPU and getting permission to use it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> gpuInstance: GPUInstance? = <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> adapter: GPUAdapter? = <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> device: GPUDevice? = <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> isInitialized = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">initialize</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (isInitialized) <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> instanceLimits = InstanceLimits()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> instanceDescriptor = InstanceDescriptor(intArrayOf(<span style="color:#ae81ff">1</span>), instanceLimits)
</span></span><span style="display:flex;"><span>        gpuInstance = createInstance(instanceDescriptor)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        adapter = gpuInstance<span style="color:#f92672">?.</span>requestAdapter()
</span></span><span style="display:flex;"><span>        device = adapter<span style="color:#f92672">?.</span>requestDevice()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        isInitialized = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (e: Exception) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Log</span>.e(<span style="color:#e6db74">&#34;WebGPU&#34;</span>, <span style="color:#e6db74">&#34;Initialization failed&#34;</span>, e)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let me break down what’s happening here:</p>
<p><strong>GPUInstance</strong> :  This is your entry point to WebGPU. It’s like opening the door to the GPU world.**</p>
<p><strong>Adapter</strong> : This represents your actual GPU hardware. A device might have multiple GPUs (like integrated and dedicated graphics cards on laptops), and the adapter lets you choose which one to use.</p>
<p><strong>Device</strong> : This is your connection to the GPU. Once you have a device, you can send commands to the GPU, create resources, and render graphics.</p>
<p><strong>Understanding Shaders</strong></p>
<p>Before we create our rendering pipeline, we need to write shaders. Remember how I mentioned shaders earlier? They’re small programs that run on the GPU. Here’s a simple shader that draws a red triangle</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> shaderCode = <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    @vertex fn vertexMain(@builtin(vertex_index) i : u32) -&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          @builtin(position) vec4f {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            const pos = array(vec2f(0, 1), vec2f(-1, -1), vec2f(1, -1));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return vec4f(pos[i], 0, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    @fragment fn fragmentMain() -&gt; @location(0) vec4f {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return vec4f(1, 0, 0, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>.trimIndent()
</span></span></code></pre></div><p>This might look intimidating, but let’s decode it piece by piece.</p>
<p><strong>The Vertex Shader (vertexMain):</strong></p>
<ul>
<li>It receives a vertex index (0, 1, or 2 for our three triangle corners)</li>
<li>It defines three positions: top-middle (0, 1), bottom-left (-1, -1), and bottom-right (1, -1)</li>
<li>These coordinates use a system where (0, 0) is the center of your screen, (-1, -1) is the bottom-left corner, and (1, 1) is the top-right corner</li>
<li>It returns vec4f(pos[i], 0, 1) which means &ldquo;use this 2D position, with a depth of 0 and a special coordinate of 1&rdquo;</li>
</ul>
<p><strong>The Fragment Shader (fragmentMain):</strong></p>
<ul>
<li>This is even simpler</li>
<li>It returns vec4f(1, 0, 0, 1) which represents a color</li>
<li>The four numbers are Red, Green, Blue, and Alpha (transparency)</li>
<li>(1, 0, 0, 1) means full red, no green, no blue, and fully opaque</li>
<li>If you wanted a blue triangle, you’d change it to vec4f(0, 0, 1, 1)</li>
</ul>
<p><strong>Creating the Surface</strong></p>
<p>A surface is where your rendered graphics actually appear. Think of it as the canvas on which the GPU paints</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">createSurface</span>(nativeSurface: Surface, width: Int, height: Int) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!is</span>Initialized) <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (width <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> height <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> nativeWindow = <span style="color:#a6e22e">Util</span>.windowFromSurface(nativeSurface)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> surfaceDescriptor = SurfaceDescriptor(
</span></span><span style="display:flex;"><span>            surfaceSourceAndroidNativeWindow = 
</span></span><span style="display:flex;"><span>                SurfaceSourceAndroidNativeWindow(nativeWindow)
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        surface = gpuInstance<span style="color:#f92672">?.</span>createSurface(surfaceDescriptor)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        configureSurface(width, height)
</span></span><span style="display:flex;"><span>        createRenderPipeline()
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (e: Exception) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Log</span>.e(<span style="color:#e6db74">&#34;WebGPU&#34;</span>, <span style="color:#e6db74">&#34;Failed to create surface&#34;</span>, e)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The Util.windowFromSurface() method converts Android's Surface object into a format that WebGPU understands. This is the bridge between Android's view system and WebGPU's rendering system.</p>
<p><strong>Configuring the Surface</strong></p>
<p>Once we have a surface, we need to configure it with the right settings</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">configureSurface</span>(width: Int, height: Int) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentSurface = surface <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentAdapter = adapter <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentDevice = device <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> capabilities = currentSurface.getCapabilities(currentAdapter)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> textureFormat = capabilities.formats.firstOrNull() <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> surfaceConfiguration = SurfaceConfiguration(
</span></span><span style="display:flex;"><span>        device = currentDevice,
</span></span><span style="display:flex;"><span>        format = textureFormat,
</span></span><span style="display:flex;"><span>        width = width,
</span></span><span style="display:flex;"><span>        height = height
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    currentSurface.configure(surfaceConfiguration)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The texture format determines how color information is stored in memory. Different devices support different formats, so we ask the GPU what formats it supports and pick the first one.</p>
<p><strong>Creating the Render Pipeline</strong></p>
<p>The render pipeline is like a recipe that tells the GPU how to process your graphics commands. It connects your shaders together and sets up all the rules for rendering</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">createRenderPipeline</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentDevice = device <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentSurface = surface <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentAdapter = adapter <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> shaderModuleDescriptor = ShaderModuleDescriptor().apply {
</span></span><span style="display:flex;"><span>            shaderSourceWGSL = ShaderSourceWGSL(shaderCode)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> module = currentDevice.createShaderModule(shaderModuleDescriptor)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> capabilities = currentSurface.getCapabilities(currentAdapter)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> textureFormat = capabilities.formats.firstOrNull() <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> colorTargetState = ColorTargetState(format = textureFormat)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> fragmentState = FragmentState(
</span></span><span style="display:flex;"><span>            module = module,
</span></span><span style="display:flex;"><span>            targets = arrayOf(colorTargetState),
</span></span><span style="display:flex;"><span>            entryPoint = <span style="color:#e6db74">&#34;fragmentMain&#34;</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> renderPipelineDescriptor = RenderPipelineDescriptor(
</span></span><span style="display:flex;"><span>            vertex = VertexState(
</span></span><span style="display:flex;"><span>                module = module,
</span></span><span style="display:flex;"><span>                entryPoint = <span style="color:#e6db74">&#34;vertexMain&#34;</span>
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>            fragment = fragmentState
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        renderPipeline = currentDevice.createRenderPipeline(renderPipelineDescriptor)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (e: Exception) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Log</span>.e(<span style="color:#e6db74">&#34;WebGPU&#34;</span>, <span style="color:#e6db74">&#34;Failed to create pipeline&#34;</span>, e)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The entry points (&ldquo;vertexMain&rdquo; and &ldquo;fragmentMain&rdquo;) tell WebGPU which functions in your shader code to use for each stage of the pipeline.</p>
<p><strong>The Render Loop</strong></p>
<p>Finally, we need to actually draw something. The render function executes every frame (ideally 60 times per second)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">render</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentSurface = surface <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentDevice = device <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> currentRenderPipeline = renderPipeline <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> surfaceTexture = currentSurface.getCurrentTexture()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> renderPassColorAttachment = RenderPassColorAttachment(
</span></span><span style="display:flex;"><span>            view = surfaceTexture.texture.createView(),
</span></span><span style="display:flex;"><span>            loadOp = Clear,
</span></span><span style="display:flex;"><span>            storeOp = Store,
</span></span><span style="display:flex;"><span>            clearValue = Color(<span style="color:#ae81ff">0.2</span>, <span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">1.0</span>)
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> renderPassDescriptor = RenderPassDescriptor(
</span></span><span style="display:flex;"><span>            colorAttachments = arrayOf(renderPassColorAttachment)
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> commandEncoder = currentDevice.createCommandEncoder()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> renderPassEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        renderPassEncoder.apply {
</span></span><span style="display:flex;"><span>            setPipeline(currentRenderPipeline)
</span></span><span style="display:flex;"><span>            draw(vertexCount = <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>            end()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> commands = commandEncoder.finish()
</span></span><span style="display:flex;"><span>        currentDevice.queue.submit(arrayOf(commands))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        currentSurface.present()
</span></span><span style="display:flex;"><span>        gpuInstance<span style="color:#f92672">?.</span>processEvents()
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (e: Exception) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Log</span>.e(<span style="color:#e6db74">&#34;WebGPU&#34;</span>, <span style="color:#e6db74">&#34;Render error&#34;</span>, e)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let’s understand what each part does:</p>
<p><strong>clearValue</strong>: This is the background color. We set it to a pleasant blue (0.2, 0.3, 0.5, 1.0).</p>
<p><strong>CommandEncoder</strong>: Instead of sending commands to the GPU one at a time, we record them into a command buffer. This is more efficient.</p>
<p><strong>RenderPassEncoder</strong>: This represents one rendering operation. We tell it to use our pipeline and draw 3 vertices (our triangle’s three corners).</p>
<p><strong>queue.submit</strong>: This sends all our recorded commands to the GPU at once.</p>
<p><strong>present</strong>: This displays the rendered result on screen.</p>
<h3 id="integrating-with-jetpack-compose">Integrating with Jetpack Compose<a hidden class="anchor" aria-hidden="true" href="#integrating-with-jetpack-compose">#</a></h3>
<p>Now that we have our renderer, we need to integrate it with Android’s UI system. We’ll use Jetpack Compose, Android’s modern UI toolkit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Composable</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">WebGPUView</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> renderer = remember { WebGPURenderer() }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> coroutineScope = rememberCoroutineScope()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> lifecycleOwner = <span style="color:#a6e22e">LocalLifecycleOwner</span>.current
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> renderJob <span style="color:#66d9ef">by</span> remember { mutableStateOf&lt;Job?&gt;(<span style="color:#66d9ef">null</span>) }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    DisposableEffect(lifecycleOwner) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> observer = LifecycleEventObserver { _, event <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (event <span style="color:#f92672">==</span> <span style="color:#a6e22e">Lifecycle</span>.<span style="color:#a6e22e">Event</span>.ON_DESTROY) {
</span></span><span style="display:flex;"><span>                renderer.cleanup()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        lifecycleOwner.lifecycle.addObserver(observer)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        onDispose {
</span></span><span style="display:flex;"><span>            lifecycleOwner.lifecycle.removeObserver(observer)
</span></span><span style="display:flex;"><span>            renderJob<span style="color:#f92672">?.</span>cancel()
</span></span><span style="display:flex;"><span>            renderer.cleanup()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LaunchedEffect(Unit) {
</span></span><span style="display:flex;"><span>        renderer.initialize()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Box(modifier = <span style="color:#a6e22e">Modifier</span>.fillMaxSize()) {
</span></span><span style="display:flex;"><span>        AndroidView(
</span></span><span style="display:flex;"><span>            factory = { context <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>                android.view.SurfaceView(context).apply {
</span></span><span style="display:flex;"><span>                    holder.addCallback(<span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">android</span>.view.<span style="color:#a6e22e">SurfaceHolder</span>.Callback {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">surfaceCreated</span>(holder: android.view.SurfaceHolder) {
</span></span><span style="display:flex;"><span>                            coroutineScope.launch {
</span></span><span style="display:flex;"><span>                                delay(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>                                
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">val</span> width = holder.surfaceFrame.width()
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">val</span> height = holder.surfaceFrame.height()
</span></span><span style="display:flex;"><span>                                
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">if</span> (width &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> height &gt; <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                                    renderer.createSurface(holder.surface, width, height)
</span></span><span style="display:flex;"><span>                                    
</span></span><span style="display:flex;"><span>                                    renderJob = launch {
</span></span><span style="display:flex;"><span>                                        <span style="color:#66d9ef">while</span> (isActive) {
</span></span><span style="display:flex;"><span>                                            renderer.render()
</span></span><span style="display:flex;"><span>                                            delay(<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>                                        }
</span></span><span style="display:flex;"><span>                                    }
</span></span><span style="display:flex;"><span>                                }
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">surfaceChanged</span>(
</span></span><span style="display:flex;"><span>                            holder: android.view.SurfaceHolder,
</span></span><span style="display:flex;"><span>                            format: Int,
</span></span><span style="display:flex;"><span>                            width: Int,
</span></span><span style="display:flex;"><span>                            height: Int
</span></span><span style="display:flex;"><span>                        ) {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span> (width &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> height &gt; <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                                renderer.createSurface(holder.surface, width, height)
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">surfaceDestroyed</span>(holder: android.view.SurfaceHolder) {
</span></span><span style="display:flex;"><span>                            renderJob<span style="color:#f92672">?.</span>cancel()
</span></span><span style="display:flex;"><span>                            renderJob = <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    })
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            modifier = <span style="color:#a6e22e">Modifier</span>.fillMaxSize()
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code sets up a SurfaceView (Android’s view for rendering graphics) and connects it to our WebGPU renderer. The render loop runs approximately 60 times per second (every 16 milliseconds).</p>
<p>Using the WebGPU View</p>
<p>Finally, you can use your WebGPU view in your Activity</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity</span> : ComponentActivity() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>        setContent {
</span></span><span style="display:flex;"><span>            MaterialTheme {
</span></span><span style="display:flex;"><span>                Surface(modifier = <span style="color:#a6e22e">Modifier</span>.fillMaxSize()) {
</span></span><span style="display:flex;"><span>                    WebGPUView()
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="final-result">Final Result<a hidden class="anchor" aria-hidden="true" href="#final-result">#</a></h3>
<p><img alt="image" loading="lazy" src="https://miro.medium.com/v2/resize:fit:1400/1*bRkeaVZjnp__onOJKQUiRQ.png"></p>
<h2 id="common-issues-and-solutions">Common Issues and Solutions<a hidden class="anchor" aria-hidden="true" href="#common-issues-and-solutions">#</a></h2>
<p><strong>Black Screen</strong>: Make sure the surface dimensions are valid. Add logging to check if initialization completed successfully.</p>
<p><strong>Library Not Found</strong>: Verify that your .so files are in the correct folders and that the folder is named jniLibs with a capital &lsquo;L&rsquo;.</p>
<p><strong>Crashes on Startup</strong>: Ensure you’re testing on a device or emulator that supports Vulkan. WebGPU on Android uses Vulkan underneath, so older devices might not work.</p>
<h2 id="whats-next">What’s Next?<a hidden class="anchor" aria-hidden="true" href="#whats-next">#</a></h2>
<p>You’ve successfully rendered your first WebGPU graphics on Android. From here, you can explore:</p>
<ul>
<li>Adding more complex shapes</li>
<li>Implementing 3D transformations</li>
<li>Adding textures and images</li>
<li>Creating interactive graphics that respond to touch</li>
<li>Building simple games or data visualizations</li>
</ul>
<p>WebGPU is a powerful technology that opens up many possibilities for graphics programming on Android. The concepts you’ve learned here, especially the graphics pipeline and shaders, are fundamental to all modern graphics programming.</p>
<p>Remember that graphics programming has a learning curve, but each concept builds on the previous one. Take your time to understand each part, experiment with the code, and don’t be afraid to make mistakes. That’s how you learn.</p>
<p><a href="https://gist.github.com/exjunk/3fba39e6b40dbf25a2711d581e39bf6e">Link to the complete code</a></p>
<p>Happy rendering!</p>
<p>Feel free to ask any questions or share your experiences on <!-- raw HTML omitted --><a href="mailto:hello@androiddevapps.com">hello@androiddevapps.com</a><!-- raw HTML omitted --> . And if you found this helpful, follow for more Android development tips! Also you connect me on <a href="https://www.linkedin.com/in/ashish-singh-0119/">linkedIn</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Android Tech Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
